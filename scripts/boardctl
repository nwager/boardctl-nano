#!/usr/bin/env python3

import serial
import sys
import os
import re
import argparse

"""
Tags to use when defining values in C files that need to be parsed by this
script. Format (with parameters):
/* {C_DEF_START} {token} */
<content>
/* {C_DEF_END} {token} */
"""
C_DEF_START = '__STARTDEF__'
C_DEF_END   = '__ENDDEF__'

DEFAULT_PORT = '/dev/ttyACM0'
SERIAL_BAUDRATE = 115200

# Map user-facing command phrases to command codename
CMD_CHOICES_MAP = {
    'reset': 'CMD_RESET',
    'recovery': 'CMD_RECOVERY',
    'toggle_power': 'CMD_POWER'
}

def parse_c_def(path: str, token: str) -> list[str]:
    """
    Parse a file for C definitions for the given token.
    
    :param path: Path of file to parse for C definitions
    :type path: str
    :param token: C definition token to parse
    :type token: str
    :return: Lines between the start and end token tags
    :rtype: list[str]
    """
    with open(path, 'r') as f:
        lines = [l.strip() for l in f.readlines()]

    try:
        start = lines.index(f'/* {C_DEF_START} {token} */')
        end = lines.index(f'/* {C_DEF_END} {token} */')
    except ValueError:
        raise ValueError(f'c_def token \'{token}\' not found')
    if start > end:
        raise ValueError(f'Failed to parse c_def \'{token}\': '
                         'Encountered end tag before start tag')

    return lines[start+1:end]

def get_command_codes() -> dict[str, int]:
    """
    Get a mapping of command code enum names to numerical values.
    
    :return: Map of command code names to numerical values
    :rtype: dict[str, int]
    """
    command_codes = {}

    project_dir = os.path.abspath(os.path.join(sys.path[0], os.pardir))
    hfile_path = os.path.join(project_dir, 'include', 'command.h')

    lines = parse_c_def(hfile_path, 'command_code')
    for l in lines:
        m = re.match(r'#define\s+(\S+)\s+(\S+)', l)
        if not m:
            continue
        command_codes[m.group(1)] = int(m.group(2))

    return command_codes

def main():
    parser = argparse.ArgumentParser(
        prog='boardctl',
        description='Send commands to the Jetson Orin Nano controller'
    )
    parser.add_argument('command',
                        choices=CMD_CHOICES_MAP.keys(),
                        help='Command to send to the controller')
    parser.add_argument('-p', '--port', default=DEFAULT_PORT,
                        help='Serial port connected to the controller')

    args = parser.parse_args()
    codes = get_command_codes()

    with serial.Serial(args.port, SERIAL_BAUDRATE) as s:
        cmd_code = codes[CMD_CHOICES_MAP[args.command]]
        payload = bytes([codes['CMD_START'], cmd_code])
        s.write(payload)

if __name__ == "__main__":
    main()
